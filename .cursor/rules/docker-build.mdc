---
description: Docker 빌드 및 모노레포 구성 시 준수해야 할 규칙
alwaysApply: true
---

## Docker 빌드 규칙

### 의존성 설치 단계 (deps) - Prisma + 네이티브 모듈

- **Prisma와 네이티브 모듈(bcrypt, sharp 등)을 사용하는 프로젝트의 올바른 전략**
 ```dockerfile
 # ✅ 올바른 예시 - Prisma 스키마를 먼저 복사하고 postinstall 허용
 FROM base AS deps
 WORKDIR /app
 
 # 네이티브 모듈 빌드 도구 설치
 RUN apk add --no-cache python3 make g++ vips-dev
 
 # package.json 파일들 복사
 COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
 COPY apps/api/package.json ./apps/api/
 COPY packages/shared/package.json ./packages/shared/
 
 # Prisma 스키마 먼저 복사 (postinstall을 위해)
 COPY apps/api/prisma ./apps/api/prisma
 
 # postinstall 스크립트 실행 허용 (prisma generate, bcrypt build 등)
 RUN pnpm install --frozen-lockfile
 
 # ❌ 잘못된 예시 - Prisma 스키마 없이 --ignore-scripts 사용
 RUN pnpm install --frozen-lockfile --ignore-scripts
 # 이 경우 bcrypt 네이티브 모듈이 빌드되지 않아 런타임 에러 발생
 ```

- **이유**: 
 - Prisma 스키마를 먼저 복사하면 `prisma generate`가 성공적으로 실행됨
 - `--ignore-scripts`를 제거하면 bcrypt, sharp 등의 postinstall 스크립트가 실행되어 네이티브 바인딩이 빌드됨
 - Alpine Linux에서 네이티브 모듈은 반드시 해당 환경에서 빌드되어야 함

- **흔한 에러 메시지**:
 ```
 Error: Cannot find module '/app/node_modules/.pnpm/bcrypt@5.1.1/node_modules/bcrypt/lib/binding/napi-v3/bcrypt_lib.node'
 ```

- **builder 단계 간소화**:
 ```dockerfile
 # deps에서 이미 모든 빌드가 완료되었으므로 TypeScript 빌드만 수행
 WORKDIR /app/apps/api
 RUN pnpm build
 ```

### TypeScript 빌드 설정

- **테스트 파일은 프로덕션 빌드에서 제외**
  ```json
  // tsconfig.json
  {
    "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
  }
  ```

- **이유**: 테스트 파일이 프로덕션 빌드에 포함되면 불필요한 컴파일 오류 발생 가능

### Fastify 응답 상태 코드

- **스키마에 정의되지 않은 상태 코드를 사용할 때는 타입 단언 필요**
  ```typescript
  // ✅ 올바른 예시
  return reply.code(400 as any).send({ error: 'Bad Request' });
  
  // ❌ 잘못된 예시 (스키마에 400이 없으면 타입 오류)
  return reply.code(400).send({ error: 'Bad Request' });
  ```

- **더 나은 방법**: 스키마에 모든 가능한 응답 코드를 정의
  ```typescript
  schema: {
    response: {
      200: zodToJsonSchema(SuccessSchema),
      400: zodToJsonSchema(ErrorSchema),
      404: zodToJsonSchema(NotFoundSchema),
    }
  }
  ```

## 모노레포 공유 패키지 규칙

### Next.js 프로젝트에서 공유 패키지 import

- **tsconfig.json과 next.config.ts 모두에 alias 설정 필요**
  ```json
  // tsconfig.json
  {
    "compilerOptions": {
      "paths": {
        "@icons/shared": ["../../packages/shared/src"],
        "@mockup-ai/shared": ["../../packages/shared/src"]
      }
    }
  }
  ```
  
  ```typescript
  // next.config.ts
  webpack: (config) => {
    config.resolve.alias = {
      ...config.resolve.alias,
      '@icons/shared': path.resolve(__dirname, '../../packages/shared/src'),
    };
    return config;
  }
  ```

- **이유**: TypeScript 컴파일러와 webpack/Turbopack 번들러는 별도로 모듈 해석 설정이 필요함

### 타입 정의 완성도

- **공유 타입을 사용할 때는 모든 필수 속성을 포함해야 함**
  ```typescript
  // ✅ 올바른 예시
  const [options, setOptions] = useState<GenerationOptionsV3>({
    viewpointLock: false,
    whiteBackground: false,
    accessoryPreservation: false,  // 필수 속성 포함
    userInstructions: '',
  });
  
  // ❌ 잘못된 예시
  const [options, setOptions] = useState<GenerationOptionsV3>({
    viewpointLock: false,
    whiteBackground: false,
    // accessoryPreservation 누락 - 컴파일 오류!
  });
  ```

## Docker 빌드 트러블슈팅 체크리스트

1. **Prisma 관련 오류**
   - [ ] `--ignore-scripts` 플래그 사용 확인
   - [ ] builder 단계에서 `npx prisma generate` 실행 확인
   - [ ] Prisma 스키마 파일이 builder 단계에서 복사되었는지 확인

2. **TypeScript 컴파일 오류**
   - [ ] 테스트 파일이 exclude에 포함되어 있는지 확인
   - [ ] 모든 필수 타입 속성이 포함되어 있는지 확인
   - [ ] 타입 import 경로가 올바른지 확인 (alias 설정)

3. **Next.js 빌드 오류**
   - [ ] tsconfig.json의 paths 설정 확인
   - [ ] next.config.ts의 webpack alias 설정 확인
   - [ ] shared 패키지가 제대로 빌드되었는지 확인

## 참고 문서

- Prisma: [prisma.mdc](mdc:.cursor/rules/prisma.mdc)
- TypeScript: [typescript.mdc](mdc:.cursor/rules/typescript.mdc)
- Fastify: [fastify.mdc](mdc:.cursor/rules/fastify.mdc)
